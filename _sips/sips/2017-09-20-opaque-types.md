---
layout: sip
title: SIP-ZZ - Opaque types

vote-status: pending
permalink: /sips/:title.html
---

**Authors: Erik Osheim and Jorge Vicente Cantero**

**Supervisor and advisor: Sébastien Doeraene**

## History

| Date          | Version       |
|---------------|---------------|
| Sep 20th 2017 | Initial Draft |

## Introduction

This is a proposal to introduce syntax for type aliases that only
exist at compile time and emulate wrapper types.

The goal is that operations on these wrapper types must not create any
extra overhead at runtime while still providing a type safe use at compile
time.

Some use cases for opaque types are:

 * New numeric classes, such as unsigned ints. There would no longer
   need to be a boxing overhead for such classes. So this is similar
   to value types in .NET and `newtype` in Haskell.

 * Classes representing units of measure. Again, no boxing overhead
   would be incurred for these classes.
   
 * Classes representing different entities with the same underlying type,
   such as `Id` and `Password` being defined in terms of `String`.
   
We expand on all these points in our [Motivation](motivation) section.

For a definition of boxing and previous state-of-the-art, we recommend reading [SIP-15].
   
### Implementation note

The proposal is currently in an early stage.
[It’s being implemented](https://github.com/scalacenter/scala/tree/opaque-type),
but the proposed implementation strategy is not detailed enough to be able
to predict with certainty that it will work as specified. Consequently,
details of the proposal might change driven by implementation concerns.

## Opaque types

### Motivation

Value classes, a Scala feature proposed in [SIP-15], were introduced to the
language to offer inlined classes whose operations have zero overhead at runtime.

This feature allows users to define classes with a few restrictions in exchange of
performance (value classes are not boxed/unboxed under some concrete scenarios,
that are deemed to be commonplace).

These scenarios, while certainly common, do not cover the majority of scenarios
that library authors have to deal with. In reality, experimentation shows that they
are insufficient, and hence performance-sensitive code suffers (see [Appendix A]).

In the following example, we show the current limitations of value classes and
motivate the need of compile-time wrapper types.

#### An example

Scala is heavily used for big data processing, where computing logarithms are a common
operation. This operation has to be fast, so library authors of numeric and big data
frameworks may define logarithms in terms of value classes:

```scala
package object valueclass {
  class Logarithm(val exponent: Double) extends AnyVal {
    def toDouble: Double = math.exp(exponent)
    def plus(that: Logarithm): Logarithm = Logarithm(`this`.toDouble + that.toDouble)
  }
  
  object Logarithm {
    def apply(exponent: Double): Logarithm = new Logarithm(exponent)
  }
}

package object usesites {
  val l: Logarithm = Logarithm(1.0)
}
```

Users of these libraries can use this `Logarithm` definition and expect fast computations
because of the lack of boxing/unboxing. This is confirmed when users have a look at the
generated bytecode for `Logarithm` and notice that the signature of `apply` is redefined as
`def apply(exponent: Double): Double` and that `val l: Logarithm = Logarithm(1.0)` is instead
`val l: Double = Logarithm.apply(1.0)`.

Scala goes far doing these transformations. For example, case classes whose fields are value
classes are also rewritten to use their underlying type.

However, let's say that a user of this library is processing a collection of logarithms:

```scala
val ls = List(Logarithm(1.0), Logarithm(2.0)).map(f)
```

When looking at the bytecode, he/she will notice that the the emitted code boxes/unboxes to
create and transform the list. [Appendix A] illustrates more cases where this unintended
boxing/unboxing happens, hurting the performance of the code.

In reality, boxing/unboxing of value classes happens anywhere in the program where the
type signatures are generic and require the runtime to pass a `java.lang.Object`.

Given the frequency of these scenarios in real-world code, we would like to introduce the
notion of compile-time wrapper types. Compile-time wrapper types do not depend on the runtime
and its capabilities, and are always erased at runtime. The previous code snippet can be
implemented using opaque types and will produce code that never boxes/unboxes.

In exchange, opaque types disallow the redefinition of `equals` and `hashCode`, which in our
experience is often unnecessary.

### Definition

Let's continue with the example in our motivation section, and define `Logarithm`
with an opaque type:

```scala
package object opaquetypes {
  opaque type Logarithm = Double
}
```

The opaque type definition is akin to the one of type aliases, except that it
is prefixed by a new `opaque` keyword.

Opaque types are always accompanied by type companions. Type companions
define the public API of an opaque type, and they are defined in the same way
that class companions are. It is possible to define an opaque type without a type
companion, but then the opaque type is useless.

Let's define a type companion for our previous opaque type `Logarithm`:

```scala
package object opaquetypes {
  // The previous opaque type definition
  opaque type Logarithm = Double

  object Logarithm {
    // These are the ways to lift to the logarithm type
    def apply(d: Double): Logarithm = math.log(d)
    def safe(d: Double): Option[Logarithm] =
      if (d > 0.0) Some(Logarithm(d)) else None
      
    // This is the first way to unlift the logarithm type
    def unapply(l: Logarithm): Option[Double] = Some(l)

    // Extension methods define opaque types' public APIs
    implicit class LogarithmOps(val `this`: Logarithm) extends AnyVal {
      // This is the second way to unlift the logarithm type
      def toDouble: Double = math.exp(`this`)
      def plus(that: Logarithm): Logarithm = Logarithm(`this`.toDouble + that.toDouble)
    }
  }
}
```

The above `Logarithm` type companion contains the following definitions:

 * Methods to lift the type from `Double` to `Logarithm`: `apply` and `safe`.
 * Extension methods to unlift the type from `Logarithm` to `Double`: `unapply` and `toDouble`.
 * Extension methods to define more operations on the type, like `plus`.
 
The key peculiarity of opaque types is that they behave like normal
[type alias]es inside their type companion; that is, users can convert from
the type alias and its equivalent definition interchangeably without the use of
explicit lift and unlift methods. We can say that opaque types are "transparent"
inside their type companion.

However, the story changes for users of this API. Outside of their type companions,
opaque types are not transparent and, therefore, the Scala compiler fails
to compile code that pretends they are. A common example is:

```scala
val l: Logarithm = 1.0
```

which fails to compile with a type mismatch error:

```scala
<console>:11: error: type mismatch;
 found   : Double
 required: Logarithm
       val l: Logarithm = 1.0
                          ^
```

The same happens for `val d: Double = l` where `l` is an instance of `Logarithm`.

The idea, then, is to let library authors create wrapper types and their API in a
concrete, isolated part of their code and force users to use this API to lift to
and unlift from the opaque type.

By design, downstream users can define more operations on these opaque types via
their own extension methods, but they cannot create a new API to lift/unlift them,
e.g. users need to use the library-provided `toDouble`, `Logarithm.safe` and
`Logarithm.apply`.

The following code showcases legit uses of the `Logarithm` opaque type:

```scala
package object usesites {
  import opaquetypes._
  val l = Logarithm(1.0)
  val l2 = Logarithm(2.0)
  val l3 = legitLogarithm.plus(l2)
  val d = l3.toDouble
  val l3: Logarithm = (1.0).asInstanceOf[Logarithm]
}
```

While the following fails to typecheck:

```scala
package object usesites {
  import opaquetypes._
  val l: Logarithm = Logarithm(1.0)
  val d: Double = l // fails to typecheck
  val l2: Logarithm = 1.0 // fails to typecheck
}
```

For the sake of completeness, this is how you extend these opaque types with more operations:

```scala
package object usesites {
  // ...
  implicit class UserOps(`this`: Logarithm) extends AnyVal {
    def times(that: Logarithm): Logarithm = Logarithm(`this`. + that)
  }
}
```

## Formal definition

The Scala Language doesn't have a concept of either opaque types or type companions. In the
following section, we formalize our previous definitions and specify the required changes to
the Scala Language Specification.

### Opaque type definition

An opaque type follows the same structure as an alias type but it requires the use of a new
`opaque` modifier.

```yaml
LocalModifier     ::=  ‘abstract’
                    |  ‘final’
                    |  ‘sealed’
                    |  ‘implicit’
                    |  ‘lazy’
                    |  ‘opaque’
```

This new modifier is then used to qualify the type alias definition:

```yaml
Def        ::= ‘opaque‘ ‘type’ {nl} TypeDef
TypeDef    ::=  id [TypeParamClause] ‘=’ Type
```

Opaque modifiers are only valid for type definitions.
Note that contrary to type alias definitions, opaque type definitions cannot be overridden.

Here's a formal definition of opaque types:

> An opaque `type t = T` defines `t` to be an alias name for the `type T` only in the scope of the opaque
type companion `t`. The left hand side of an opaque type may have a type parameter clause, e.g.
`type t[tps] = T`. The scope of a type parameter extends over the right hand side `T` and the type
parameter clause `tps` itself.

As per this definition, opaque types modify the type equivalence relationship explained in the
[3.5.1. Equivalence] section of the Scala Language Specification. In particular, the next item
qualifies the type equivalence for opaque types:

> If `t` is defined by an opaque type `opaque type t = T`, then `t` is not equivalent to `T` unless
`t` occurs in the template of the opaque type companion.

In the [Implementation notes](implementation-notes), we explain how this can be achieved in the
implementation.

### Opaque type companion

We define a type companion in a similar way companion classes are described in the Scala Language
Specification in [5.5. Object Definitions]:

> Generally, a companion module of an opaque type is an object which has the same name as the opaque
type and is defined in the same scope and compilation unit. Conversely to companion classes, the
companion class of the module does not have a notion of companion type.

#### Opaque type companions and implicit search

These opaque type companions are also part of the implicit search scope of the opaque type `t`. 
Therefore, uses of extension methods defined in the opaque type companion do not require users
to import the opaque type companion explicitly.

### Technical discussions

In our current proposal, we make several trade-offs. Next, we defend these trade-offs and propose
alternative ways to achieve the same (if any).

#### `opaque` as a modifier

Note that adding `opaque` as a modifier prevents the use of `opaque` anywhere in the users'
program, which could possibly break someone's code. To fix this scenario, we could create a
Scalafix rule that will rewrite any place where `opaque` is an identifier.

For those SIP Committee members wary of adding a new keyword to the language, we propose an
alternative approach. Instead of defining opaque types with the `opaque` modifier, opaque types
may also be defined by combining the existing `new` and `type` keywords, e.g.
`new type Logarithm = Double`. This option would be akin to the syntax used in Haskell for wrapper
types, e.g. `newtype`.

#### Type companions

This proposal only adds the notion of type companions for opaque types. After discussing with
members of the SIP Committee and Scala compiler hackers, we believe that a notion of type companions
extended to type aliases would not work because the typechecker aggressively dealiases**, and it is
not possible to link to the type companion symbol once type aliases have been dealiased.

** Note that dealiasing means [beta reducing] a type alias.

## Implementation notes

To implement opaque types, we need to modify three compiler phases: parser, namer and typer. At the
time of this writing, it is unclear if later phases like erasure must be changed as well, but we
think this should not be necessary.

There are several key ideas in the current, work-in-progress implementation:

 * To meet the type equivalence relationship for opaque types, we synthesize two implicit conversions
   inside the opaque type companion, if they do not already exist. If `opaque type t = T`, then
   two implicit conversions are synthesized, one from `t` to `T` is synthesized and another for the
   other way around. The body of these methods will use `t.asInstanceOf[T]` and viceversa **.

 * Phases after typer always dealias opaque types. This way, erasure and codegen can unwrap opaque
   types out of the box and, at the bytecode level, their underlying representation is used instead.
   
All these ideas are open to refinements by the SIP Committee.

** Note that these `asInstanceOf` can be removed at compile-time, but there is no precedent of
doing so in the Scalac compiler. However, it is not clear whether leaving these casts will have
an impact on performance -- the underlying virtual machine may remove the operation based on type
analysis due to the fact that the cast is from `Double => Double`.

# Cross-platform

We believe that by implementing opaque types early in the pipeline, [Scala.js] and [Scala Native]
can compile them out-of-the-box. Thus, we do not expect opaque types to have problems for different
backends, since erasure will always see the dealiased types.

# Examples

## Example 1

The program statements on the left are converted using steps 1 to 3 to
the statements on the right.

    var m, n: Logarithm       var m, n: Double
    var o: AnyRef             var o: AnyRef
    m = n                     m = n
    o = m                     o = m.asInstanceOf[AnyRef]
    m plus n                  Logarithm.extension1$plus(m, n)
    o.isInstanceOf[Logarithm] o.isInstanceOf[Double]
    o.asInstanceOf[Logarithm] o.asInstanceOf[Double]
    m.isInstanceOf[Logarithm] m.isInstanceOf[Double]
    m.asInstanceOf[Logarithm] m.asInstanceOf[Double]

## Example 2

After all 3 steps the `Logarithm` class is translated to the following
code.

```scala
object Logarithm {
  def logOf(n: Double): Double = {
    require(n > 0.0)
    math.log(n)
  }

  // generated methods follow
  def extension$toDouble($this: Double): Double =
    math.exp($this)

  def extension1$plus($this: Double, that: Double): Double =
    Logarithm.logOf(Logarithm.extension$toDouble($this) + Logarithm.extension$toDouble(that))

  def extension2$plus($this: Double, n: Double): Double =
    Logarithm.logOf(Logarithm.extension$toDouble($this) + n)

  def extension$times($this: Double, that: Double): Double =
    $this + that
}
```

Note that the two `plus` methods end up with the same type in object
`Logarithm`. That’s why we needed to distinguish them by adding an
integer number.

The same situation can arise in other circumstances as well: Two
overloaded methods might end up with the same type after
unwrapping. In the general case, Scala would treat this situation as
an error, as it would for other types that get erased. So we propose
to solve only the specific problem that multiple overloaded methods in
a newtype class itself might clash after unwrapping.

## Further Optimizations?

We could imagine this newtype feature being generalized to tuples. In
that case, a newtype class could wrap *N* values (0-22), and be
represented either by 0-22 positional parameters (in the extension
methods) or by a single tuple of the appropriate arity (when a reified
value was needed, e.g. for use in a collection).

Newtype classes as written here can already wrap tuples in a
transparent way, so the required addition would be allowing multiple
parameters to be provided positionally rather than in a tuple
(i.e. adding two kinds of extension method for every method in the
base class).

Work in this direction should only start once single-parameter newtype
classes are implemented (at least experimentally), since one of the
places multi-value newtype classes may struggle is in performance.

## Conclusion

We believe that opaque types fit in the language nicely. The combination of type aliases and value
classes (for the zero runtime overhead of extension methods) result in compile-time wrapper types

## References

1. [(Appendix A) The High Cost of AnyVal classes][Appendix A]

[Appendix A]: https://failex.blogspot.ch/2017/04/the-high-cost-of-anyval-subclasses.html
[Scala Language Specification]: https://www.scala-lang.org/files/archive/spec/2.12/
[type alias]: http://www.scala-lang.org/files/archive/spec/2.12/04-basic-declarations-and-definitions.html#type-declarations-and-type-aliases
[5.5. Object definitions]: http://www.scala-lang.org/files/archive/spec/2.12/05-classes-and-objects.html#object-definitions
[3.5.1. Equivalence]: http://www.scala-lang.org/files/archive/spec/2.12/03-types.html#equivalence
[Scala.js]: https://www.scala-js.org/
[Scala Native]: https://github.com/scala-native/scala-native
[beta reducing]: https://en.wikipedia.org/wiki/Beta_normal_form
[SIP-15]: http://docs.scala-lang.org/sips/value-classes.html
